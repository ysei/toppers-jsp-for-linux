
           ＝ TOPPERS/JSPカーネル ユーザズマニュアル ＝
    （Windows シミュレーション環境，タスク−スレッド対応モデル）

            （Release 1.4 対応，最終更新: 20-Dec-2003）

------------------------------------------------------------------------ 
 TOPPERS/JSP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Just Standard Profile Kernel

 Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
                             Toyohashi Univ. of Technology, JAPAN

 上記著作権者は，以下の (1)〜(4) の条件か，Free Software Foundation 
 によって公表されている GNU General Public License の Version 2 に記
 述されている条件を満たす場合に限り，本ソフトウェア（本ソフトウェア
 を改変したものを含む．以下同じ）を使用・複製・改変・再配布（以下，
 利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，その適用可能性も
 含めて，いかなる保証も行わない．また，本ソフトウェアの利用により直
 接的または間接的に生じたいかなる損害に関しても，その責任を負わない．

 @(#) $Id: windows.txt,v 1.19 2004/05/27 08:50:32 honda Exp $
------------------------------------------------------------------------

このドキュメントでは，TOPPERS/JSP Windowsシミュレーション環境部分につ
いて解説する．

-------------------------------------------------------
１． Windowsシミュレーション環境 ターゲット依存部の概要
-------------------------------------------------------

--------------------------------
1.1 ターゲットシステムと開発環境
--------------------------------

Windowsシミュレーション環境の実行環境としては，次のものを想定している．

    ・Microsoft Windows 2000/XP Pro (x86)
        #Windows XP Home Editionでの検証は行っていない

また開発環境として次のものを想定している．
    ・Microsoft Visual C++ 6.0
       #一部のコードにインラインアセンブラを使用しているため、
       #MSVC以外の処理系を用いることはできない

また付属する追加機能を利用するために、次のものが必要になる場合がある．
    ・Microsoft VisualBASIC 6.0
    ・Active Template Library 3.0 (Visual C++ 6.0に含まれる)
    ・Microsoft Foundation Class Library 6.0 (Visual C++ 6.0に含まれる)

補足

TOPPERS/JSP Windowsシミュレーション環境の開発は次の環境で行われている．

   [OS]     ・Microsoft Windows XP Professional
                + Service Pack 1
   [処理系] ・Microsoft Visual Studio .NET Academic   (主たる開発環境)
                + .NET Framework ServicePack 1
            ・Microsoft Visual Studio .NET Enterprise Architect
                + .NET Framework ServicePack 1
            ・Microsoft Visual Studio 6.0 Enterprise
                + Microsoft Visual Studio 6.0 ServicePack5
                + Microsoft Visual C++ Processor Pack
            ・RedHat cygwin (API:0.94, 1005.5.0.0)


--------------------------
1.2 サポートする機能の概要
--------------------------

Windowsシミュレーション環境に依存した機能として，割込みマスクの変更・参
照(chg_ixx, get_ixx)と割り込みの禁止・許可(dis_int, ena_int)をサポートし
ている．また性能評価用システム時刻参照機能(vxget_tim)をサポートしている．

Windowsシミュレーション環境は，トレースログ出力機構を備えている．同機能
は，単体起動時ではファイル出力の形で，デバイスエミュレーション機能使用時
にはCOM通信の形で使用することができる．

-----------------------------------------------------
1.3 TOPPERS/JSP Windowsシミュレーション環境の制限事項
-----------------------------------------------------

    ・デフォルトのタイマ分解能は100ms
        Windowsシミュレーション環境ではタイマティックは100msとなっている．
        ただし単位はmsのままであり，50msのdly_tskを発行した場合 100ms秒後に
        処理が行われれることになる．
        ただし，ソースの一部を変更することで，理論上1msにまで変更できる．

    ・タスクスタック，非タスクコンテキスト用スタックは自動生成
        各コンテキストで必要なスタックはWindowsが生成するため，コンフィギュ
        レータが標準で生成するスタックは利用されない．またスタック領域が不
        足した場合，Windowsが自動的に領域を再割り当てする．

------------------------------
1.4 バージョン変遷による変更点
------------------------------

・Release 1.3 から Release 1.4へ
	- Windows 9x系カーネルをサポート外に
		# MicrosoftがWindows98をサポート対象外としたため
	- メールスロット版デバイスエミュレーション機能を廃止
	- デバイスエミュレーションのロック範囲が選択式に
	- プロジェクトディレクトリの移動に伴いパスなどを変更


---------------------------------------------
２．Windowsシミュレーション環境に依存した機能
---------------------------------------------

この節では，カーネルおよびシステムサービスの機能の中で，Windowsシミュレ
ーション環境依存の部分について解説する．

------------
2.1 データ型
------------

int型 および unsigned int型のサイズは32ビットである．
 #IA-64など64ビット整数を基本とする環境は考慮していない

----------------------------------
2.2 割込み管理機能と割込みハンドラ
----------------------------------

Windowsシミュレーション環境ではm68k方式の割込みをエミュレーションしている．
ただしNMIをサポートしないため，全ての割り込みはカーネルの管理内で発生する．
CPUロック状態や初期化ルーチン内では割込みマスクに7が設定され，全ての割り込み
が禁止される．

デフォルトの割込み要因数は7つであり，7を最大優先度とする．割り込み要因の数は
cpu_defs.h:15のINT_NUMINTERRUPTSを修正することで任意に増やすことが可能である
 (ただし最低割込み要因番号は1に固定されている)．通常タイマ割込みが要因番号4
 を利用する．これ以外の割込みはユーザが次の関数を利用して任意に発生させるこ
 とができる．

    割り込み要求の発生
        void HALInterruptRequest(unsigned int intno)
        割り込み要因番号intnoに割り込み要求を発生させる

DEF_INHで指定する割込みハンドラ番号(inhno)は，68000での例外ベクタ番号を
表し，そのデータ型(INHNO)はunsigned int型に定義されている．DEF_INHで無効
な例外ベクタ番号を指定した場合の動作は保証されない．

Windowsシミュレーション環境依存の機能として，割込みマスクの値を変更する
ためのサービスコール chg_imsと，参照するためのサービスコール get_ims を
サポートしている．なお，割込みマスクの値を表すデータ型はunsigned intであ
る．


TOPPERS/JSP Windowsでは次の関数をサポートしている．

BOOL def_int( unsigned int ims, void * rtn);    /* ハンドラ定義 */

ER  ena_int(unsigned int ims);          /* 許可 */
ER  dis_int(unsigned int ims);          /* 禁止 */
ER  chg_ims(unsigned int ims);          /* 割込みレベルの設定 */
ER  get_ims(unsigned int *p_ims);       /* 割込みレベルの取得 */

def_int : 割込みハンドラ定義
    割込みハンドラrtnを割込み要因番号imsに対応づける

ena_int : 割込み許可
    割込み要求を許可する．引数は無視され，全許可となる

dis_int : 割込み禁止
    割込み要求を禁止する．引数は無視され，全禁止となる

chg_ims : 割込みレベル設定
    割込み要求マスクレベルを引数で設定した値に設定し，
    以降マスクレベル以下の割込み要求は禁止となる

get_ims : 割込みレベルの取得
    割込み要求マスクレベルを取得し，引数で示された場所に格納する


------------------------------------
2.3 CPU例外管理機能とCPU例外ハンドラ
------------------------------------

Windowsシミュレーション環境では、Windowsの例外をCPU例外に割り当てている。

DEF_EXCで指定する割込みハンドラ番号(excno)はWindowsの例外要因番号を表し，そ
のデータ型(EXCNO)はunsigned int型に定義されている．DEF_EXC で，例外ベクタ番
号として有効でない値や，CPU例外に対応しない番号を指定した場合の動作は保証さ
れない．

Windows上で例外が発生した場合，対応付けられたCPU例外ハンドラを起動した後，他
のWindows例外ハンドラへ処理を渡す．デバッガなどが起動している場合はデバッガ
によってハンドリングされるため，たいていの場合はエラーとなってその場で停止す
る．

Windowsシミュレーション環境では，次の引数を伴ってCPU例外ハンドラを起動する．

	void cpuexc_handler( EXCEPTION_POINTERS * exc, int * ctrl )
		exc  : 例外発生時の詳細情報を含む構造体へのポインタ
		ctrl : 例外発生後の動作

ctrlは例外発生後、例外ハンドリングルーチンの動作を決定する。この値に格納すべ
き値は、UnhandledExceptionFilterが返すべき値である。
EXCEPTION_CONTINUE_SEARCHが指定された場合は上位の例外ハンドリングルーチンへ
制御を移し、EXCEPTION_CONTINUE_EXECUTIONが指定された場合は例外が発生した場所
から実行を再開する。ただし、EXCEPTION_CONTINUE_EXECUTIONを指定する場合には、
例外発生の原因となった要因を取り除かなければ、再度例外が発生することに注意さ
れたい。詳細はMSDNライブラリなどを参考のこと。

------------------
2.4 カーネルタイマ
------------------

Windowsシミュレーション環境では，カーネルタイマを次の3種類のタイマのうち
から選択できる．

	・Windows標準タイマ		: 低精度だが低負荷．最小ティックは10ms．
	・マルチメディアタイマ	: 高精度だが高負荷．最小ティックは1ms．
	・タイマなし			: 外部プログラムによって独自に供給する場合．

タイマを変更する場合は，sys_defs.h:65-67の定義のうち，各対応行のコメント
を解除し，他の行(#define TIMER_で始まる行)をコメントアウトする．

タイムティックは100msに設定されているが、hw_timer.h:59の
TIMER_CLOCK_WINDOWSを修正することで変更できる。しかし、
TIMER_WINDOWSTIMERは10ms以下で動作させることはできず、また
TIMER_MULTIMEDIATIMERは前者よりも処理が重いため、あまりにも短く設定しす
ぎるとタイマ処理だけでCPU時間を使い切る恐れがる。


-------------------------------------------
３．Windowsシミュレーション環境に固有な機能
-------------------------------------------

----------------------------
3.1 シリアルエミュレーション
----------------------------

TOPPERS/JSP Windowsは，コンソールを模したシリアルエミュレーション機能を
備えている．同機能を使用すると，画面に「シリアル入出力」と名づけられたウ
ィンドウを表示し，シリアル出力された内容を表示する．また同ウィンドウに足
して行われたキー入力をシリアル入力としてアプリケーションに通知する．


----------------------
3.2 デバッグコンソール
----------------------

TOPPERS/JSP Windowsシミュレーション環境では，デバッグ文字列を出力するための
専用コンソールを提供している．デバッグコンソールでは簡単な記述でデバッグ文字
列を出力することができ，通常のシリアルを利用しなくとも画面だけでフローのデバ
ッグなどが行える．
 #ItIs/Winに搭載されていたカーネル内部情報表示は別ユニットとなった

デバッグコンソールを有効にするにはsys_defs.h:56の
 //#define DEBUG_ENABLE
のコメントをはずし，宣言を有効にすることで利用可能となる．
無効にするには該当個所の宣言を削除またはコメントアウトすればよい．

TOPPERS/JSP Windowsシミュレーション環境では，次のデバッグ用機能を提供してい
る．

OnDebug : デバッグ時のみ有効となる行につける宣言
    行の頭にOnDebugをつけることで，DEBUG_ENABLE時にのみ有効となる行を簡単に
    作ることができる．
    
    DEBUG_ENABLE時   : #define OnDebug(x) x
    非DEBUG_ENABLE時 : #define OnDebug(x)

    例
        OnDebug(wsprintf(buffer,"i = %d",i));

unsigned int DebugOut(LPCSTR text) : デバッグコンソールへの出力
    DebugOut関数はデバッグコンソールへ文字列を出力する．
    
    非DEBUG_ENABLE時にはコメント行になる．


------------------------------
3.3 タスクトレイ (Notify Icon)
------------------------------

TOPPERS/JSP Windowsシミュレーション環境では，通常プログラムは見えない存在と
して動作する．しかしそれではプログラムの終了を確認する手段がなくなってしまう
危険性を伴う．そのためWindowsシミュレーション環境では画面右下のタスクトレイ
上にアイコンが表示され，プログラムが現在実行中であるかどうかが確認できるよう
になっている．

またこのトレイ上のアイコンを右クリックすることで，プログラムを強制終了させる
ことが可能である．

DEBUG_ENABLE時にはTOPPERS/JSP Windowsシミュレータの本体となるウィンドウを強
制的に表示させるようになっている．この場合は本体となるウィンドウを終了させる
ことでプログラムを強制終了させることができる．


----------------------------
3.4 デバイスエミュレーション
----------------------------

TOPPERS/JSP Windowsシミュレーション環境では、システムに接続されたデバイ
ス(LEDなど)をエミュレートするための機構をもっている．デバイスエミュレー
ションでは次のようなことができる．

    ・カーネルが特定の番地をアクセスした場合、デバイスに通知する
    ・カーネルに対して割り込みを発生させる
    ・カーネルの起動および終了をデバイスに通知する
        ※それぞれの機構は専用関数を通して利用する

マッピング対象となる空間は実メモリとは異なる空間である (Intelプロセッサ
のI/Oポートを想定していただきたい)。そのためマッピングされたされた空間へ
のアクセスは専用関数を介して行う。デバイスは空間が重複しなければ複数起動
することが可能である。またカーネルも複数起動することが可能であるが、デバ
イスエミュレーション機構を利用できるカーネルはシステム内で単一である。

デバイスエミュレーションはデフォルトで無効となっているが、config/windows
/sys_defs.h:58のコメントを解除することで有効にできる。無効にするには該当
行を再度コメントアウトすれば、関連する全ての項目が無効となる。

カーネルから利用できるデバイスエミュレーション関連の関数を下に示す。
また全ての関数はデバイスエミュレーション無効時にはコメント行として扱われる。

--- ITRONデバイスドライバガイドライン互換インタフェース ---

VB sil_reb_mem(VP mem), VH sil_reh_mem(VP mem), VW sil_rew_mem(VP mem),
void sil_rek_mem(VP mem, VP data, UINT len)
    指定されたサイズで、指定されたアドレスにマッピングされているデバイス
	からメモリリードを行う。後述のDeviceReadのラッパ。

void sil_wrb_mem(VP mem, VB data), void sil_wrh_mem(VP mem, VH data)
void sil_wrw_mem(VP mem, VW data), void sil_wrk_mem(VP mem, VP data, UINT len)
    指定されたサイズで、指定されたアドレスにマッピングされているデバイス
	へメモリ書込みを行う。後述のDeviceWriteのラッパ。


--- 独自インターフェース ---
void InitializeComSupportModule(void)
    デバイスエミュレーション関連の初期化を行う。
    基本的にカーネルが起動時に初期化を行うため、ユーザが呼ぶ必要はない。

void FinalizeComSupportModule(void)
    デバイスエミュレーション関連の終了処理を行う。
    カーネル脱出時に終了処理を行っているので、能動的に呼ぶ必要はない。

int DeviceRead(unsigned long address, unsigned long size, void * storage)
    デバイスからの読出し
        address : デバイスを識別するためのアドレス値など
                   (実メモリ空間とは独立)
        size    : 読み出す長さ
        storage : 格納先へのポインタ
        返却値  : 読み出されたデータのバイト数 または -1(失敗)
    
    addressにマッピングされたデバイスからsizeバイトのデータを読出し、
    storageに格納する。マッピングされたデバイスがない場合、関数は-1
    を返却する。発行時のロック状態は，タスク毎/システム全体のどちらかが選
	択できる (デフォルトはシステム全体)．

int DeviceWrite(unsigned long address, unsigned long size, void * storage)
    デバイスへの書込み
        address : デバイスを識別するためのアドレス値など
                   (実メモリ空間とは独立)
        size    : 書き込む長さ
        storage : 出力データを格納する領域へのポインタ
        返却値  : 書き込まれたデータのバイト数 または -1(失敗)

    addressにマッピングされたデバイスへstorageに格納されたsizeバイトのデ
    ータを書き込む、storageに格納する。マッピングされたデバイスがない場合
    、関数は-1を返却する。発行時のロック状態はタスク毎/システム全体が選択
	可能．
----------------------------

デバイスエミュレーション機能は，発行時にシステム全体をロックさせるか発行
したタスクのみをロックさせるかを選択することができる．デフォルトでは，発
行時にはシステム全体がロックする．ロック範囲をタスクのみに変更する場合，
com_support.cpp:697-698を次のように修正する．

---8<---
	typedef class Request DeviceRequest;
//	typedef class ExclusiveDeviceRequest DeviceRequest;
---8<---

デバイス本体およびデバイスマネージャに関しては後述の5.1を参照のこと。

-----------------------------------
3.5 カーネルトレースログ (実行履歴)
-----------------------------------

Windows依存部では、TOPPERS/JSP rel 1.4からカーネルのトレースログ取得機能
を実装している。本機能はITRONデバッギングインタフェース仕様に準じて実装
されている。以下に本機能を介して利用できる情報(イベント)を挙げる。カッコ
内はそれぞれのイベントで取得できる詳細情報を示す (※は拡張機能)。

	・ITRONデバッギングインタフェース仕様(1.00.00)にて定義されたログ
		- 割込みハンドラの起動 および 終了
				(割込み番号)
		- タスクディスパッチの開始 および 終了
				(タスク番号, コンテキスト状態)
		- 周期ハンドラの開始 および 終了
				(周期ハンドラのID, 拡張情報)
		- タスク/CPU例外の開始 および 終了
				(タスク番号, 例外パタン / 例外番号)
		- タスク状態変化
				# ITRON-DBIFではReadyとRunを区別しない (ディスパッチログを使用)
		- サービルコールの起動 および 終了
			[実行] 機能コード, 引数, 呼出元アドレス(※)
			[終了] 機能コード, エラーコード
				# サービスコール終了時パラメータはエラーコードのみ
				# 一部実装依存/実装定義/独自関数は対象外

カーネルログを無効にするには、config/windows/sys_defs.h内で
EVENTLOG_ENABLEをコメントアウトする。カーネルログはデフォルトで有効とな
っているが、config/windows/sys_defs.hの当該部をコメントアウトすることで
無効にできる。

トレースログ機能を利用するには、クライアントソフトウェアが必要になる。
TOPPERS/JSP release 1.4では、jsp/windev/cmdwatchにコマンドラインで動作す
るログ表示プログラムが同梱されており、同プログラムを実行後にカーネルを起
動することで、画面にカーネルのログ情報を出力することができる。
 # cmdwatchの実行には、デバイスマネージャが必要となる。
 # デバイスマネージャに関しては、後述の5.1節を参照されたい。

VisualBASICからログ情報を使用したい場合は、jsp/windev/watcherをビルドし、
同コントロールを使用する。

カーネルのトレースログは、カーネルと非同期に出力される。そのため、ログ出
力項目が多すぎる場合、カーネルが消費するメモリ量が増大したり、カーネルの
動作とログ内容が一致しないことがある。またカーネル終了時に全てのログ情報
を出力するため、終了処理が長引くことがある。

出力するログを抑止するには、カーネル内部で次の命令を実行する。

・割込み開始/終了ログの抑止
		BOOL set_intlogmask( unsigned int ims, BOOL mask );
			ims  : 割込み要因番号
			mask : ログを出力する (TRUE) / ログを抑止する (非TRUE)


------------------
４．開発環境の構築
------------------

------------------
4.1 開発環境の概要
------------------

カーネルを実行するには，JSPカーネルの配布キットに含まれる以外に，以下の
ツールおよびライブラリが必要である．

Microsoft Visual C ++ (6.0/.NET/.NET 2003にて確認)
    単体にて動作可能

なお、TOPPERS/JSP release 1.3 (patchlevel=1)ではcygwin+gccでのコンパイル
は行えない。TOPPERS/JSP release 1.4 用のcygwin対応コードは，TOPPERSプロ
ジェクトの成果物ではないため，公式リリースには含めていない．

-----------------------------------------------
4.1.1 Microsoft Visual C++を利用する場合 (自動)
-----------------------------------------------

開発を行っている環境がWindows Scripting Hostの実行環境を持つ場合、かつ使
用している処理系がMicrosoft VisualC++ 6.0である場合に限り、TOPPERS/JSPの
生成に自動生成スクリプトが利用できる。
 # .NET / .NET2003には非対応

注) 自動生成スクリプトは、各サブスクリプトを起動するために、Windows 
Scripting Hostの機能であるWScript.WshShell.Runメソッドを利用している。一
部のセキュリティソフトウェアは上記メソッドを使用するスクリプトを悪質と判
断し、実行をブロックする場合がある。

自動生成スクリプトは、 jsp/WINDOWS/configure.vbs という名前で格納されて
いる。このスクリプトを実行すると、コンフィギュレータの生成およびデバイス
エミュレータの生成を行い、Visual C++を起動した後サンプルプロジェクトを開
く。ほとんどの場合では、初期設定のままプロジェクトのビルドを行えば、
TOPPERS/JSP Windowsシミュレーション環境の実行形式を得ることができる。

次のファイルを実行することで、個々の部品ごとに生成することも可能である。
	コンフィギュレータ/構成チェッカ : jsp/cfg/vc_project/make.vbs
	デバイスエミュレータ			: jsp/windev/make.vbs

-----------------------------------------------
4.1.2 Microsoft Visual C++を利用する場合 (手動)
-----------------------------------------------

まずコンフィギュレータを生成する．コンフィギュレータは/cfg/VC_Project/内
にあるMicrosoft Visual C++プロジェクトファイルを開くことにより，諸設定を
せずとも即ビルドが可能な状態になる．標準では，cfg.exeはjsp/cfg/cfg.exeと
して作成されている．

このとき、同時にカーネルチェッカも生成する。カーネルチェッカをビルドする
には、メニューから「プロジェクト」「アクティブプロジェクトの設定」「
checker」を選択し、ビルドメニューからビルドを選択する。カーネルチェッカ
は "Windows ImageHlp API"を使用しているため、生成時にはライブラリ
IMAGEHLP.LIBが必要になる。サンプルプロジェクトファイルの設定には、プログ
ラムが使用するライブラリモジュールとしてIMAGEHLP.LIBが追加されている。正
常にビルドが終了すると、標準では、実行ファイルはjsp/cfg/chk.exeとして作
成されている。

TOPPERS/JSP Windowsシミュレーション環境の構築はMicrosoft Visual C++のプ
ロジェクト ワークスペースを利用する．/config/WINDOWS/vc_project内にある
プロジェクトファイルおよびワークスペースを開くことで，構築に必要な設定を
全て終えた状態で起動する．

 #このプロジェクトではサンプルプログラムが生成されるようになっている

付属のサンプルプログラムではすでに設定がされているが，サンプル以外のコン
フィギュレーションファイルを利用する場合，コンフィギュレータにkernel_id.
hとkernel_cfg.cを作成させる必要がある．以下に設定法を示す．
 (ここでは，コンフィギュレータは/jsp/cfg/cfg.exeであるとしている)

  (a) Visual C++ に行わせる場合
      1.  対象となるcfgファイルを選択し，コンテキストメニュー(右クリック)から
          設定を選択する．
      2.  一般から「常にカスタムビルドステップを使用」を有効にする
      3.  カスタムビルドタブを選択肢，コマンド部に次のコマンドを打つ
			---8<--- ここから ---8<---
			cd $(InputDir)
			cl /E /I "../../kernel" /I "../../include" /I "../../config/windows" \
				$(InputName).cfg | ..\cfg\cfg.exe -s -c -v -obj -lj -cpu windows
			---8<--- ここまで ---8<---
           #行末に\のある行は行末の\を削除し、後続する行を続けて入力する

      4.  出力部に次のファイルを打つ
            kernel_cfg.c
            kernel_id.h
      5.  メニューから「プロジェクト」「設定」を選択し、ダイアログ内のタブ
          「ビルド後の処理」を選択する
      6.  ビルド後の処理コマンドとして、次のコマンドを入力する。
			---8<--- ここから ---8<---
			cd ..
			..\..\cfg\chk.exe -m toppers.exe -cs windows.chk -obj -v -lj
			---8<--- ここまで ---8<---

  (b) コマンドラインから直接打つ場合
      1. Visual C++をインストールした場所のBinフォルダにある
          VCVARS32.BATを実行する
           
           #インストール時に「コマンドラインから実行するための
           #バッチを作らない」と指定するとこのファイルはない
           
      2. コンフィギュレーションファイルのあるディレクトリで
         次のコマンドを入力する
			---8<--- ここから ---8<---
			cl /E /I "../../kernel" /I "../../include" /I "../../config/windows" \
				<ファイル名> | ..\..\cfg\cfg.exe -s -c -v -obj -lj -cpu windows
			---8<--- ここまで ---8<---
           #行末に\のある行は行末の\を削除し、後続する行を続けて入力する

kernel_id.hとkernel_cfg.cが生成されたら，これらのファイルをプロジェクトに追
加し，Visual C++からビルドを行えばプログラムが生成される．

付属のプロジェクトファイルでは，それぞれ適切なフォルダにファイルが格納される
ようになってる．ユーザプログラムはSource FilesとHeader Filesに格納される．サ
ンプル以外のプログラムを利用される場合，この2つのフォルダに格納されているフ
ァイルをプロジェクトから削除してから，新しいプログラムを追加する必要がある．


--------------------------
５．特殊な機構に関する説明
--------------------------

----------------------------
5.1 デバイスエミュレーション
----------------------------

----------------------------------------
5.1.1 デバイスエミュレーション環境の作成
----------------------------------------

デバイスエミュレーション機構は3つのプログラムからなる。
    ・カーネル
        デバイスを制御するアプリケーションが搭載されたプログラム。サービ
        ス対象となるカーネルはシステム内で単一 (起動するだけなら複数可)。
    ・デバイスマネージャ
        カーネルからの要求に対して適切なデバイスに要求を回送するプログラ
        ム (イベントディスパッチャ)。カーネルまたはデバイスが起動すると
        COMによって自動的に起動する。システム内で単一。
    ・デバイス
        デバイスのエミュレーションを行うプログラム。カーネルから発行され
        た要求にしたがって処理を行う。マッピング空間が重複しなければ複数
        起動可能。VisualBASICを利用することもできる。

カーネルのデバイスエミュレーション機能の作成に関しては 3.4デバイスエミュ
レーション を参照されたい。

デバイスマネージャおよびVisualBASIC用デバイスコントロールの作成には次の
ツールが必要になる。
    ・Microsoft Visual C++ 6.0/.NET/.NET2003
    ・Microsoft VisualBASIC 6.0/.NET/.NET2003 ※
    ・COM実行環境 (Windows 2000/XP)
    ・Active Template Library 3.0 (Visual C++ 6.0以降に含まれる)

		※ VisualBASICは6.0と.NETの間で言語仕様が大きく変化しているため，
		   .NET以降の場合，後述の作成例はそのままでは使用できない

デバイスマネージャは次のようにして作成する。
基本的に，ビルドを行うだけでサーバ登録およびプロキシ/スタブ登録を行う．

   (0. アクティブな構成の設定をDebugにするか、例外周りの設定を変える)
    1. Visual C++を起動し、プロジェクトワークスペースdevicemanager.dswを
        開く
    2. ビルドを行う
    3. OLE Viewを起動し、Interfacesの中にIDeviceとIKernelがあることを
        確認する (プロキシ/スタブDLLのインストール確認)

 プロキシ/スタブDLLが正しく導入されない場合は，次の作業を要する．
    1. コマンドプロンプトを起動する
    2. Visual C++をインストールしたディレクトリのbin/VCVARS32.BATを実行し
        関連ツールが使えるようにする
    3. プロジェクトのあるディレクトリへ移動する
    4. 次のコマンドを実行する
        nmake devicemanagerps.mk
    5. 次のコマンドを実行する
        regsvr32 devicemanagerps.dll

 デバイスマネージャの実行プログラムの場所を移動したい場合には、
 次の作業を要する．
    1. devicemanager.exeを移動する
    2. 移動した先で、次のコマンドを実行する
        regsvr32 devicemanager.exe

デバイスマネージャを移動する場合には、次の作業を要する。

    1. コマンドプロンプトを起動し、実行ファイルを移動させる
    2. 移動させた後、オプション "/RegServer" をつけて実行する
        > devicemanager.exe /RegServer

デバイスマネージャを削除する場合には、次の作業を要する。

    1. コマンドプロンプトからオプション "/UnregServer" をつけて実行する
        > devicemanager.exe /UnregServer
    2. 実行ファイルを削除する


VisualBASIC用デバイスコントロールの作成には、次の作業を要する。
基本的に，ビルドを行うだけでサーバ登録およびプロキシ/スタブ登録を行う．

    1. Visual C++を起動し、プロジェクトワークスペースdevice.dswを開く
    2. ビルドを行う
    3. OLEViewを起動し、InterfacesにIDeviceControlがあることを
        確認する

VisualBASIC用デバイスコントロールの移動には、次の作業を要する。

    1. device.dllを移動する
    2. コマンドプロンプトから次のコマンドを発行する
        regsvr32 (移動先)\device.dll

VisualBASIC用デバイスコントロールの削除には、次の作業を要する。

    1. コマンドプロンプトから次のコマンドを発行する
        regsvr32 /u (インストール先)\device.dll
    2. DLLを削除する

-----------------------------------------------
5.1.2 VisualBASIC用デバイスコントロールの使い方
-----------------------------------------------

TOPPERS/JSP Windows のデバイスエミュレーションで利用されるデバイスは、Vi
sualBASICを利用しても作成可能である。VisualBASICを利用することで、短時間
でエミュレータを作成できる。本項ではVisualBASIC用デバイスコントロールの
概要と、簡単な作成手順を示す。

TOPPERS/JSP on Windows Device Componentで提供される機能は次の通り

オブジェクト DeviceControl

    メソッド Public Sub Connect()
        デバイスマネージャとの通信を確立させる。
        確立前にConnect以外のメソッドを実行すると失敗する。
        失敗するとE_FAILが返る。
    
    メソッド Public Sub Close()
        デバイスマネージャとの通信を終了する。
        失敗するとE_FAILが返る。

    メソッド Public Sub RaiseInterrupt(ByVal inhno as long)
        カーネルプロセスにハンドラ番号inhnoの割込みを発生させる。
        失敗するとE_FAILが返る。0以下の値は設定できない。

    メソッド Public Sub Map(ByVal address as long, ByVal size as long)
        このデバイスをアドレスaddressからsizeバイトのサイズでマッピングする。
        以後、対象領域にアクセスがあると、イベントが発生する。
    
    メソッド Public Sub Unmap(ByVal address as long)
        アドレスaddressを含むようなマップ済み領域のマッピングを解除する。
        以後、対象領域にアクセスがあってもイベントは発生しない。
    
    プロパティ Public Valid as BOOL [R]
        このデバイスが有効であるときにはTrueとなる。
    
    プロパティ Public IsKernelStarted as BOOL [R]
        カーネルが起動しているとTrueとなる。
    
    プロパティ Public Offset as long [RW]
        送受信データバッファのオフセット位置を指定/取得する。
        単位はバイト単位である。
    
    プロパティ Public AccessSize as short [RW]
        アクセス単位を指定/取得する。
        数値は1,2,4のいずれかである。
    
    プロパティ Public Value as long [RW]
        プロパティOffsetの位置からプロパティAccessSizeバイトの
        リトルエンディアンに従い数値表現したものを取得/設定する。
        アクセスが行われるとOffsetの値をAccessSizeだけ増加させる。
        
        イベントOnRead時における読込みは無効となる。
        イベントOnWrite時における書き込みは無効となる。
    
    イベント Private Sub OnRead(ByVal address as long, ByVal sz as long)
        カーネルからaddress番地に対するszバイトの読込みがあったことを通
        知する。デバイスはその返答となる値を格納しなければならない。
        イベント発生時にはOffsetは常に0となる。
        OnReadイベント発生時にはValueに対する読込みはできない。
        
    イベント Private Sub OnWrite(ByVal address as long, ByVal sz as long)
        カーネルからaddress番地に対するszバイトの書込みがあったことを通
        知する。デバイスはその値から適切な処理を行わなければならない。
        イベント発生時にはOffsetは常に0となる。
        OnWriteイベント発生時にはValueに対する書き込みはできない。
    
    イベント Private Sub OnKernelStart()
        カーネルが起動したことを通知する。
    
    イベント Private Sub OnKernelExit()
        カーネルが終了したことを通知する。


デバイスオブジェクトは送受信データを簡単に扱うために、内部にバッファ機構
を持っている。このバッファ機構はプロパティAccessSize, Offset, Valueの3つ
を利用して取得/設定することが可能となる。

例として、カーネルから0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xefとい
う8バイトのデータが送られてきた場合、Valueに格納されているデータはそれぞ
れAccessSizeに従って次のように取得される。またValueにアクセスすると自動
的にOffsetがAccessSize分インクリメントされるため、連続して取得すると連続
するデータを取得することになる。

        表: AccessSizeによるValueの値の変化
        +----+----------------------------+
        |    |          AccessSize        |
        |回数+------+--------+------------+
        |    |   1  |     2  |      4     |
        +----+------+--------+------------+
        +----+------+--------+------------+
        |  1 | 0x01 | 0x2301 | 0x67452301 |
        |  2 | 0x23 | 0x6745 | 0xefcdab89 |
        |  3 | 0x45 | 0xab89 |  -未定義-  |
        |  4 | 0x67 | 0xefcd |  -未定義-  |
        |  5 | 0x89 | 未定義 |  -未定義-  |
        |  6 | 0xab | 未定義 |  -未定義-  |
        |  7 | 0xcd | 未定義 |  -未定義-  |
        |  8 | 0xef | 未定義 |  -未定義-  |
        |  9 |未定義| 未定義 |  -未定義-  |
        +----+------+--------+------------+


sample1.cを改造して、現在動いているタスク番号を表示するようなデバイスを
作成する手順を示す。この改造はVisualBASIC 6.0での記述である．VB.NET以降
を使用している場合，適切な形に修正すること．

1. Visual C++ を起動し、カーネルのプロジェクトを開く

2. sample1.cに #include "device.h" を追加する

3. sample1.c:387のsyslogの手前に次の行を入れる
    DeviceWrite(0x1234, 1, &tskno);
        #この命令によってポート0x1234番地に1バイトのレジスタを持つ
        #デバイスにデータを出力できる

4. ビルドする

5. VisualBASIC 6.0を起動し、「標準EXE」を選択し、開く

6. メニューから「プロジェクト -> コンポーネント」を選択する

7.コントロールの中から
    「TOPPERS/JSP on Windows Device Component Type Library」をチェックして、
    OKを押す。

8.ツールボックスからDeviceControlを選択し、フォームに貼る(DeviceControl1)

9.ラベルをひとつフォームに貼る(Label1)

10.フォームをダブルクリックし、Form_Loadを実装する

    Private Sub Form_Load()
        DeviceControl1.connect       'デバイスマネージャと接続する
        DeviceControl1.Map &H1234, 1 '0x1234番地に1バイトのレジスタをマップする
    End Sub

11.続いてForm_Unloadを実装する

    Private Sub Form_Unload(Cancel As Integer)
        DeviceControl1.Close    'デバイスマネージャとの接続を解除する
    End Sub

12.受信時の動作を記述するために、DeviceControl1_OnWriteを実装する

    Private Sub DeviceControl1_OnWrite(ByVal address As Long, ByVal sz As Long)
        Label1 = Str(DeviceControl1.Value)
    End Sub

13.プログラムを実行し、カーネルを起動する
14.シリアル入出力に'r'を入力して、表示される数字が変化すればOK。

補足
 デバイスのVisibleプロパティをFalseに設定すれば、実行時に絵が表示されない

サンプルとして、windev/devicecontrol/sampleにはWINDOWS/sample2.cで利用できる
デバイスのユーザインタフェースのVisualBASICプログラムがある。sample2.cのカー
ネルとともに使用すれば、現在の哲学者の状況を表示してくれる。

--------------------------------
5.1.3 デバイスマネージャの操作法
--------------------------------

TOPPERS/JSP 1.4に付属のデバイスマネージャから，トレイアイコンを表示する
ようになっている．トレイアイコンを右クリックすることでメニューを表示する
ことができる．

メニューには，現在のカーネルの動作状態，接続済みデバイス数，割付済み空間
数，接続済みウォッチャ数が表示され，またデバイス一覧と強制終了の項目があ
る．

デバイスマネージャは，カーネルおよび接続デバイスおよび接続ウォッチャがひ
とつもなくなってから一定時間が経過すると自動的に終了する．しかし，デバイ
スマネージャが不正動作のために終了しない場合には，メニューから強制終了さ
せることができる．特に全てのデバイスを終了させてもメニュー中の接続デバイ
ス数が0にならない場合，またカーネルも起動していない状況にも関わらずメニ
ュー中に「カーネル起動中」と表示される場合は，強制終了することでデバイス
エミュレーション機能を正常に動作できるようになる．

---------------------------
5.1.4 おかしいな?と思ったら
---------------------------

・どう見ても動いてない
    - sys_defs.hのDEVICE_ENABLEの行が有効になっていますか？
    - レジストリに次のキーがあるか調べてみてください。
        51789667-9F20-40AF-AF7F-9856325DFB0B
      このキーがある場合は、このキーのLocalServer32に記述されたファイルが
      ちゃんとあるかどうか調べてみてください。また、カーネルを実行中に
      このファイルも実行されているか確かめて見てください。
    - VBのデバイス側でもDevice.Connectをちゃんと実行しているか調べてみて
      ください．

・マッピングで失敗する
    すでにデバイスマネージャが起動しており、特定ポートが埋まっていると
    思い込んでいる可能性があります。Ctrl+Alt+Delや、タスクマネージャを
    使って，メモリに常駐しているデバイスマネージャを一度終了させてから、
    再度実行してみるとうまく行くかもしれません。


--------------------
5.2 トレースログ機能
--------------------

----------------------------
5.2.1 トレースログ環境の作成
----------------------------

トレースログ機構は、3つのプログラムから構成されている。
	・カーネル
		ログ取得の対象となるカーネル。サービス対象となるカーネルは
		システム内で単一 (ただし、複数指定時には警告あり)。
	・デバイスマネージャ
		カーネルが出力したログを適切なログウォッチャに回送するプロ
		グラム (イベントディスパッチャ)。カーネル または ウォッチャ
		が起動すると、COMによって自動起動する。システム内で単一。
	・ログウォッチャ (ウォッチャ)
		ログを用いた処理を行うプログラム。カーネルが生成したログの
		情報に応じて、様々な処理を行う。複数起動可能。

トレースログ機能は、前節のデバイスエミュレーション機能を拡張する形で提供
されている。環境の構築方法に関しては、5.1.1項を参照のこと。

カーネルログ機構の一部は、デバイスマネージャによって提供されている。デバ
イスマネージャの生成・登録・削除については、「5.1.1 デバイスエミュレーシ
ョン環境の作成」を参照されたい。

VisualBASIC用ログウォッチャコントロール(COM版)の作成には、次の作業を要す
る。基本的に，ビルドを行うだけでサーバ登録およびプロキシ/スタブ登録を行
う．

    1. Visual C++を起動し、プロジェクトワークスペースwatcher.dswを開く
    2. ビルドを行う
    3. OLEViewを起動し、InterfacesにIKernelLogControlがあることを
        確認する

VisualBASIC用ログウォッチャコントロール(COM版)の移動には、次の作業を要する。

    1. device.dllを移動する
    2. コマンドプロンプトから次のコマンドを発行する
        regsvr32 (移動先)\watcher.dll

VisualBASIC用ログウォッチャコントロール(COM版)の削除には、次の作業を要する。

    1. コマンドプロンプトから次のコマンドを発行する
        regsvr32 /u (インストール先)\watcher.dll
    2. DLLを削除する


-----------------------------------
5.2.2 コマンドライン ログウォッチャ
-----------------------------------

コマンドラインログウォッチャは、カーネルログを画面表示すると同時に、
"kernel-log-[日付]-[時刻].log"というファイルを生成してログを保存する。フ
ァイルはカーネルの起動イベント毎に生成されるため、コマンドラインログウォ
ッチャは一度起動すれば、カーネルの起動毎に起動しなおす必要は無い。

プログラムを生成するには、Visual C++ 6.0などのMS系処理系で
jsp/windev/cmdwatch/cmdwatch.dswを開き、ビルドを行えばよい。

コマンドラインログウォッチャはCtrl-Cイベントをフックしているので、プログ
ラムを終了するにはCtrl-Cを押下すればよい。Ctrl-Cを押下すれば現在出力して
いるログファイルをクローズし、プログラムを停止する。

本プログラムはログ機構を使用するための環境を提供すると同時に、ログを使用
したプログラムを作成する際のサンプルでもある。

Windowsはコンソールアプリケーションの文字表示が遅い。カーネルのログ機構
はログウォッチャの速度に依存するため、コマンドラインログウォッチャを使用
するとカーネルの速度が低下する。画面表示が必要ないのであれば、ウィンドウ
をアイコン化したり、cmdwatch.cppのPrintf関数内で画面へ出力している個所を
コメントアウトするなどで速度をあげることができる。

------------------------------------
5.2.3 VB用ログウォッチャコントロール
------------------------------------

VB用ログウォッチャコントロールは、カーネルが出力したログをVisual BASICア
プリケーションで使用するためのコントロールである。本コントロールを使用す
ることで、Microsoft Excelなどを使用して統計処理の自動化などが行える。

説明内でITRON-DBIFと記載のある個所に関しては、ITRONデバッギングインタフ
ェース仕様 1.00.00 を参照されたい。

	メソッド Public  Sub Open()
		ログウォッチャをマネージャへ登録する。

	メソッド Public  Sub Close()
		ログウォッチャを登録解除する。

	プロパティ Public Type as Long [R]
		最後に発生したログの種別を取得する。

	プロパティ Public Logtim as Long [R]
		最後に発生したログのカーネル時刻を取得する (単位はms)。

	プロパティ Public isValid as Bool [R]
		ログウォッチャが正常に動作しているときにTRUEを返す。

	プロパティ Public Param (index as Long) as Long [R]
		各ログ種別毎の追加情報を取得する。
		項目に関してはITRON-DBIFを参照されたい。

	イベント Private Sub OnKernelStart()
		カーネルが起動したことを通知する。

	イベント Private Sub OnkernelExit()
		カーネルが終了したことを通知する。

	イベント Private Sub OnLogEvent( ByVal type as Long )
		イベントの発生を通知する。
			type : イベント種別 (ITRON-DBIF)
					0x1 : 割込みハンドラ開始		0x81 : 同終了
					0x2 : ISR開始 (非サポート)		0x82 : 同終了 (NOSPT)
					0x3 : 周期ハンドラ開始			0x83 : 同終了
					0x4 : CPU例外開始				0x84 : 同終了
					0x5 : タスク例外開始			0x85 : 同終了
					0x6 : タスク状態変化
					0x7 : タスク->ディスパッチャ	0x87 : ->タスク
					0x8 : SVC実行開始				0x88 : SVC実行終了

------------------
5.2.4 ファイル出力
------------------

トレースログ機能は、前述のデバイスマネージャを介してログを出力する方法の
ほかに、ファイルに直接ログをダンプする方法も備える。同手法を有効にするた
めには、com_support.cpp:585-586にある定義を次のように入れ替える。

--- 修正前 ---
//typedef class EventDumpRequest EventRequest;
  typedef class Request          EventRequest;
--- 修正後 ---
  typedef class EventDumpRequest EventRequest;
//typedef class Request          EventRequest;
--------------

  ※上記修正を行うとデバイスマネージャにログ情報を出力しないため、
    ウォッチャが沈黙することに留意されたい。

EventDumpRequestが生成するファイルは、ITRONデバッギングインタフェース仕
様の標準ログ形式ではなく、同仕様で定義されたログ取得用構造体のダンプイメ
ージである。ただし、同ファイルを閲覧/編集するプログラム(winwatch)は、
TOPPERSプロジェクトの成果物ではないため、公式リリースには含まれない。


----------
６．その他
----------

------------------------------
6.1 ディレクトリ・ファイル構成
------------------------------

------------------------------------------
6.1.1 TOPPERS/JSP Windows-HAL 構成ファイル
------------------------------------------

[jsp]
  +- [config]
  |   +- [windows]
  |       +- api.h              : APIガード通過用定義ファイル
  |       +- com_support.cpp    : COM関連機能実装部
  |       +- com_support.h      : COM関連機能定義部
  |       +- cpu_config.c       : プロセッサ依存モジュール
  |       +- cpu_config.h       : プロセッサ依存モジュール
  |       +- cpu_context.h      : タスクコンテキスト操作ルーチン
  |       +- cpu_defs.c         : m68k風の割込みエミュレータ
  |       +- cpu_defs.h         : m68k風の割込みエミュレータ
  |       +- cpu_rename.h       : シンボル名衝突回避ヘッダファイル
  |       +- cpu_rename.def     : 衝突回避シンボル名定義ファイル
  |       +- cpu_unrename.h     : シンボル名衝突回避ヘッダファイル
  |       +- debugout.c         : デバッグコンソールモジュール
  |       +- debugout.h         : デバッグコンソール定義ファイル
  |       +- device.h           : デバイスエミュレーション用定義ファイル
  |       +- eventlog.c         : トレースログ機能 補助関数実装部
  |       +- eventlog.h         ; トレースログ機能 補助関数定義部
  |       +- hal_msg.h          : カーネルシミュレータ メッセージ定義ファイル
  |       +- hal_resource.rc    : TOPPERS/JSP Windows リソースファイル
  |       +- hw_timer.h         : タイマ操作
  |       +- hw_serial.h        : シリアルエミュレーション ヘッダ
  |       +- hw_serial.c        : シリアルエミュレーション 実装
  |       +- icon1.ico          : アイコンファイル
  |       +- messages.h         : デバイスエミュレーションメッセージ定義
  |       +- primary_thread.c   : エントリ
  |       +- resource.h         : リソースID定義ファイル
  |       +- sys_config.c       : システム依存モジュール
  |       +- sys_config.h       : システム依存モジュール
  |       +- sys_defs.h         : システム依存定義ファイル
  |       +- sys_rename.h       : シンボル名衝突回避ヘッダファイル
  |       +- sys_rename.def     : 衝突回避シンボル名定義ファイル
  |       +- sys_unrename.h     : シンボル名衝突回避ヘッダファイル
  |       +- vitron.h           : itron.h衝突回避用ヘッダファイル
  |       +- vwindows.h         : windows.h衝突回避用ヘッダファイル
  +- [tools/WINDOWS]
      +- configure.vbs          : 自動生成スクリプト
      +- kernel_cfg.c           : コンフィギュレータ生成ファイル
      +- kernel_id.h            : 自動割当ID定義ファイル
      +- sample1.c              : サンプルプログラム
      +- sample1.h              : サンプルプログラム ヘッダー
      +- sample1.cfg            : サンプルプログラム カーネル構成ファイル
      +- sample2.c              : サンプルプログラム2 哲学者問題
      +- sample2.h              : サンプルプログラム2 ヘッダー
      +- sample2.cfg            : サンプルプログラム2 カーネル構成ファイル
      +- windows.chk            : Windows用チェックスクリプトファイル
      +- [vc_project]
          +- Toppers.dsp        : Visual C++ プロジェクトファイル
          +- Toppers.dsw        : Visual C++ ワークスペース


---------------------------------------------------------
6.1.2 TOPPERS/JSP Windows サポートモジュール 構成ファイル
---------------------------------------------------------

[windev]
  +- make.vbs                   : 自動生成スクリプト
  |
  +- [cmdwatch]                 : コマンドラインベース ログウォッチャ
  |   +- cmdwatch.cpp           : ログウォッチャ本体
  |   +- cmdwatch.dsw           : Visual C++ ワークスペースファイル
  |   +- cmdwatch.dsp           : Visual C++ プロジェクトファイル
  |
  +- [devicemanager]            : デバイスマネージャ(COM)
  |   +- device.cpp             : デバイスオブジェクト
  |   +- device.h               : デバイスオブジェクト定義ファイル
  |   +- device.rgs             : デバイスオブジェクト登録ファイル
  |   +- devicemanager.cpp      : メインプログラム
  |   +- devicemanager.dsp      : Visual C++ プロジェクトファイル
  |   +- devicemanager.dsw      : Visual C++ ワークスペース
  |   +- devicemanager.h        : オブジェクト定義ファイル
  |   +- devicemanager.idl      : MIDLオブジェクト記述ファイル
  |   +- devicemanager.rc       : リソースファイル
  |   +- devicemanager.rgs      : AppIDレジストレーションファイル
  |   +- devicemanagerCP.h      : コネクションポイントプロキシ
  |   +- devicemanager_?.c      : プロキシ/スタブコード
  |   +- devicemanagerps.def    : プロキシ/スタブ定義
  |   +- devicemanagerps.mk     : プロキシ/スタブ Makefile
  |   +- icon1.ico				: タスクトレイ用アイコン
  |   +- informat.bin           : Informationオブジェクト登録ファイル
  |   +- information.cpp        : 情報提供オブジェクト
  |   +- information.h          : 情報提供オブジェクト定義ファイル
  |   +- information.rgs        : Informationレジストレーションファイル
  |   +- kernel.cpp             : カーネルオブジェクト
  |   +- kernel.h               : カーネルオブジェクト定義ファイル
  |   +- kernel.rgs             : カーネル登録ファイル
  |   +- messages.h             : メッセージ定義ファイル (旧バージョン用)
  |   +- range.h                : レンジ型定義ファイル
  |   +- resource.h             : リソース定義ファイル
  |   +- stdafx.cpp             : メインオブジェクト
  |   +- stdafx.h               : プリコンパイル対象ヘッダ
  |
  +- [devicecontrol]            : VB用デバイスコントロール(COM)
  |   +- bmp00001.bmp           : コントロール表示用アイコン
  |   +- device.cpp             : DLL関連処理
  |   +- device.def             : プログラム定義ファイル
  |   +- device.dsp             : Visual C++ プロジェクト
  |   +- device.dsw             : Visual C++ ワークスペース
  |   +- device.h               : オブジェクト定義ファイル
  |   +- device.idl             : MIDLオブジェクト定義ファイル
  |   +- device.rc              : リソースファイル
  |   +- deviceCP.h             : コネクションポイントプロキシ
  |   +- deviceco.bmp           : アプリケーションアイコン
  |   +- devicecontrol.cpp      : デバイスコントロール
  |   +- devicecontrol.h        : デバイスコントロール定義ファイル
  |   +- deviceps.def           : プロキシ/スタブ定義
  |   +- resource.h             : リソース定義ファイル
  |   +- stdafx.h               : プリコンパイル対象ヘッダ
  |   +- stdafx.cpp             : (特になし)
  |   +- [sample]               : デバイスのサンプル
  |       +- form1.frm          : フォーム (テキスト)
  |       +- form1.frx          : フォーム (バイナリ)
  |       +- sample2_ui.vbp     : VisualBASICプロジェクトファイル
  |       +- sample2_ui.vbw     : VisualBASICワークスペース
  |
  +- [watcher]                  : VB用ログウォッチャコントロール(COM)
      +- kernello.bmp           : ログウォッチャアイコン
      +- kernellogcontrol.cpp   : カーネルログウォッチャ 本体
      +- kernellogcontrol.h     : カーネルログウォッチャ ヘッダファイル
      +- resource.h             : リソースID定義ファイル
      +- stdafx.h               : プリコンパイル対象ヘッダファイル
      +- stdafx.cpp             : (特になし)
      +- watcher.cpp            : コントロール制御ルーチン
      +- watcher.def            : プログラム定義ファイル
      +- watcher.dsp            : プロジェクトファイル
      +- watcher.dsw            : ワークスペース
      +- watcher.rc             : リソースファイル
      +- watcher_?.c            : プロキシ/スタブコード
      +- watcherCP.h            : コネクションポイント定義ファイル
      +- watcherps.def          : プロキシ/スタブ定義ファイル

------------------
７．バージョン履歴
------------------

バージョンは3桁から成り、JSPのバージョン番号と一致する。バージョン以外に
名称がついているものは、内部配布/特殊用途(プロトタイプなど)を意味する。

	2003年12月19日  Release 1.4
		・リリース準備
		・プロジェクトディレクトリの移動に伴う修正
			- ドキュメント
			- プロジェクトファイル

	2003年12月 3日  Release 1.4 - Prerelease γ
		・ディスパッチ禁止中に割込みが入るとディスパッチが起こるバグを修正
		・デバイスマネージャをトレイに載せてメニューを追加
		・COM通信リクエストにExclusiveRequestを追加

	2003年11月10日  Release 1.4 - Prerelease β4 (続き)
		・話題沸騰ポットとの仲が悪くなってきたので仲裁/調停
			- デバイスマネージャのコードの一部をリファクタ
			- ET2003のデモ用にログウォッチャを修正
		・デバイスマネージャのメニューにマップ済みデバイス一覧を追加

	2003年 8月21日  Release 1.4 - Prerelease β4 (続き)
		・cygwinでコンパイルできるように手を加えた
		・マルチプロセッサ用にAffinityMaskを設定
		・コンソールの初期化で落ちるパスを見直した

	2003年 6月17日  Release 1.4 - Prerelease β4
		・シリアルドライバの更新に合わせてこちらも直す
		・トレースログをファイルにダンプする機能を追加

	2003年 5月 9日  Release 1.4 - Prerelease β3
		・COM通信ルーチンを挿し直す
		・システムロック制御の導入
		・デバッグ用変数をいくつか導入
		・マルチメディアタイマを使用

	2003年 2月 1日  Release 1.4 - Prerelease β2
		・DesignWave誌の付録にするためにコメントなどを修正

	2003年 1月19日  Release 1.4 - Prerelease 2
		・toppers-staff向けに配布 (1.4 Release Candidate)
			- Release 1.4 向けの修正
			- シリアルコンソールがタスクバーに乗らないのを修正
			- sys_putcの実装

	2002年12月20日  Release 1.4 - Prerelease 1
		・プロジェクトメンバ向けに配布
			- カーネル内ログポイント 正式反映
			- ログ取得機構 バグフィクス
			- ログ機構の実装

	2002年 9月 4日  Release 1.4 - Technical Preview
		・ログ取得インタフェース実装
			- カーネル内ログポイント埋め作業
			- デバイスマネージャにログ回送ルーチンを実装
			- ウォッチャ作成

	2002年 7月 7日  Release 1.3.1(続き)
		・タスク例外が管理スレッド上で実行されてしまうのを回避
			この修正によりMSVCでのコンパイルが必須に
		・割込みエミュレータのena_int/dis_intを作り変える
		・ところどころにコメントをうつ
		・DebugOut関数を改造

	2002年 6月30日  Release 1.3.1
		・Release 1.3のときに直したと思っていたシリアルドライバのバグを修正
			- 管理スレッドがJSPの関数を使い、一貫性が失われるバグを修正
		・Release 1.3の後に見つかったバグのフィックス
			- ドキュメントの修正 (デバイスマネージャ チュートリアル)
			- カーネル側のデバイスエミュハンドラスレッドのDispatchMessageの
				パラメータがポインタになっていなかったのを修正
			- ShellNotifyIconの削除に使っていたhWndが登録時と異なっていたために
				終了後もアイコンが削除されなかったバグを修正
		・デバイスマネージャの修正
			- カーネルにKeepAlive確認割込みを設置し、カーネル強制終了後に
				デバイスマネージャに接続できなくなるバグを修正
			- 多重カーネル起動時に、どちらに接続するか確認するように修正

	2002年 4月 6日  Release 1.3
		・Release 1.3に向けたさまざま調整
			- WSH自動生成スクリプトの導入
			- 新規コンフィギュレータへの対応
			- コンフィギュレーションチェッカをデフォルトで使用するよう修正
			- このドキュメントの修正

	2001年11月15日  Release 1.2
		・Release1.2をリリース
			- 内部と外部のバージョンを合わせるため、rel 1.2をスキップ

    2001年11月12日  Release 1.1.6
        ・Release1.2に向けたさまざまな調整
            - 標準ビルド用ワークスペース & プロジェクトの変更
            - 無限待ち回避用強制シャットダウンスレッドの導入
            - このドキュメントの修正

    2001年11月 1日  Release 1.1.5
        ・sample1.cのビルド
            - ドキュメント中のsample1.cのビルド方法にあるcfg.exeのパスが間違っているのを修正
                # jsp/WINDOWS/cfg.exe -> jsp/cfg/cfg.exe
            - 上記修正に伴い、sample1.c用のプロジェクトワークスペースを修正

    2001年10月24日  Release 1.1.4
        ・デバイスエミュ大暴走対策
            - COMデバイスエミュが外部からの割込み要求を受け入れないバグを修正

    2001年 9月13日  Release 1.1.3
        ・検定仕様書対策
            - sns_dpnがCPU例外時にFALSEとなるバグを修正
            - ShellNotifyIconが消えないバグを修正
            - sample1.cのCPU例外をアクセス違反から、ユーザ定義例外へ修正 (例外復帰対策)

    2001年 7月29日  Release 1.1.2
        ・シリアルコンソールによるスタック破壊の回避
            - KeyEventTrapperのCALLBACK指定が不足していたのを修正

    2001年 3月24日  Release 1.1.1
        ・カーネルのデバイス終了無限待ちの回避
            - デバイス終了イベントをSIGNAL状態にする前に削除してしまい、
               カーネルが無限待ちに陥ってしまうバグを修正

    2001年 2月23日  Release 1.1
        ・TOPPERS/JSP release 1.1に合わせいろいろ修正
            - デバイスマネージャのファイル名を規約に従い修正
            - デバイスコントロールのファイル名を規約に従い修正
            - sample2.cをデバイスデモ用に書き直す

    2001年 2月20日  Release 1.0.8
        ・バグフィックスとか
            - HALMSG_MESSAGESをWM_USERからWM_APPに
            - PrimaryDialogHandleの代入位置を修正

    2001年 1月29日  Release 1.0.7
        ・デバイスコントロールをリリース用に修正
            - グラフィックの修正/追加
            - OnDraw関数の修正
            - IDL helpstringの追加
            - device_com.cppにコメントを追加

    2001年 1月12日  Release 1.0.6
        ・マニュアルのデバイスサポートに関する説明を追加

    2001年 1月 4日  Release 1.0.5
        ・諸設定部をsys_defs.hに追い出す
        ・終了ルーチンの一部を改良

    2000年12月30日  Release 1.0.4
        ・デバイスサポート機構をつける (COM)
        ・一部のハンドルの表記を正式なものにかえる (HANDLE->HWNDなど)

    2000年12月21日  Release 1.0.3
        ・デバイスサポート機構をつける (メールスロット版)

    2000年12月12日  Release 1.0.2
        ・Visual C++のプロジェクトファイルの位置を移動
        ・この文章のミスを何点か修正

    2000年11月24日  Release 1.0.1
        ・タスク例外が発生しないバグを修正
        ・コンソールシリアルドライバがスタックを破壊するのを修正
    
    2000年11月15日  Release 1.0
        ・最初のリリース

以上
